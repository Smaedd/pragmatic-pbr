#pragma glslify: envMapEquirect     = require(../../local_modules/glsl-envmap-equirect)
#pragma glslify: envMapCube         = require(../../local_modules/glsl-envmap-cube)
#pragma glslify: toGamma            = require(glsl-gamma/out)
#pragma glslify: toLinear           = require(glsl-gamma/in)
#pragma glslify: tonemapUncharted2  = require(../../local_modules/glsl-tonemap-uncharted2)
#pragma glslify: random             = require(glsl-random)

//Disney
//https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf

#ifdef GL_ES
precision highp float;
#endif

#ifdef GL_ES
  #extension GL_EXT_shader_texture_lod : require
#else
  #extension GL_ARB_shader_texture_lod : require
#endif

uniform bool uUE4;
uniform bool uUE4Prefiltered;

uniform mat4 uInverseViewMatrix;
uniform float uExposure;
uniform sampler2D uHammersleyPointSetMap;

varying vec3 vPositionWorld;
varying vec3 vPositionView;
varying vec3 vNormalWorld;
varying vec3 vNormalView;
varying vec2 vTexCoord;

varying vec3 vLightPosView;

struct FragData {
  vec3 color;
  vec3 albedo;
  float opacity;
  float roughness;
  float metalness;
  vec3 specularity;
  vec3 positionWorld;
  vec3 positionView;
  vec3 normalWorld;
  vec3 normalView;
  vec2 texCoord;
  vec3 eyePosView;
  vec3 eyeDirWorld;
  vec3 eyeDirView;
  vec3 lightColor;
  float lightAtten;
  vec3 lightPosView;
  vec3 lightPosWorld;
  vec3 lightDirView;
  vec3 lightDirWorld;
  vec3 reflectionColor;
  vec3 irradianceColor;
  float exposure;
};



//Sampled from a texture generated by code based on
//http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
vec2 Hammersley(int i, int N) {
    return texture2D(uHammersleyPointSetMap, vec2(0.5, (float(i) + 0.5)/float(N))).rg;
}

float saturate(float f) {
    return clamp(f, 0.0, 1.0);
}

uniform vec4 uAlbedoColor; //assumes sRGB color, not linear

vec3 getAlbedo(inout FragData data) {
    return toLinear(uAlbedoColor.rgb);
}

uniform float uRoughness;

float getRoughness(inout FragData data) {
    return uRoughness;
}

uniform float uMetalness;

float getMetalness(inout FragData data) {
    return uMetalness;
}

uniform samplerCube uReflectionMap;

vec3 getReflection(inout FragData data) {
    float maxMipMapLevel = 7.0; //TODO: const
    vec3 reflectionWorld = reflect(-data.eyeDirWorld, data.normalWorld);
    vec3 R = envMapCube(reflectionWorld);
    float k = 1.0 - (1.0 - data.roughness) * (1.0 - data.roughness);
    float lod = k * maxMipMapLevel;
    float upLod = floor(lod);
    float downLod = ceil(lod);
    //vec4 a = textureCubeLod(reflectionMap, fixSeams(reflectionWorld, upLod), upLod);
    //vec4 b = textureCubeLod(reflectionMap, fixSeams(reflectionWorld, downLod), downLod);
    vec3 a = textureCubeLod(uReflectionMap, R, upLod).rgb;
    vec3 b = textureCubeLod(uReflectionMap, R, downLod).rgb;
    return mix(a, b, lod - upLod);
    //return textureCubeLod(uReflectionMap, , data.roughness * 8.0).rgb;
}


uniform samplerCube uIrradianceMap;

vec3 getIrradiance(inout FragData data) {
    float maxMipMapLevel = 7.0; //TODO: const
    vec3 reflectionWorld = reflect(-data.eyeDirWorld, data.normalWorld);
    vec3 R = envMapCube(reflectionWorld);
    return textureCube(uIrradianceMap, R).rgb;
}

//Based on Real Shading in Unreal Engine 4
vec3 ImportanceSampleGGXUE4(vec2 Xi, float Roughness, vec3 N) {
    //this is mapping 2d point to a hemisphere but additionally we add spread by roughness
    float a = Roughness * Roughness;
    float Phi = 2.0 * PI * Xi.x + random(N.xz) * 0.1;
    float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
    float SinTheta = sqrt(1.0 - CosTheta * CosTheta);
    vec3 H;
    H.x = SinTheta * cos(Phi);
    H.y = SinTheta * sin(Phi);
    H.z = CosTheta;

    //Tangent space vectors
    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 TangentX = normalize(cross(UpVector, N));
    vec3 TangentY = normalize(cross(N, TangentX));

    //Tangent to World Space
    return TangentX * H.x + TangentY * H.y + N * H.z;

    //
    //vec3 n = N;
    //float aa = 1.0 / (1.0 + n.z);
    //float b = -n.x * n.y * aa;
    //vec3 b1 = vec3(1.0 - n.x * n.x * aa, b, -n.x);
    //vec3 b2 = vec3(b, 1.0 - n.y * n.y * aa, -n.y);
    //mat3 vecSpace = mat3(b1, b2, n);
    //return normalize(mix(vecSpace * H, N, 1.0 - Roughness));
}


float G_Smith(float Roughness, float NoL, float NoV) {
    float k = (Roughness + 1.0) * (Roughness + 1.0) / 8.0;
    float G1l = NoL / (NoL * (1.0 - k) + k);
    float G1v = NoV / (NoV * (1.0 - k) + k);
    float Glvh = G1l * G1v;
    return Glvh;
}

//Frostbite
vec3 F_Schlick(vec3 F0, float fd90, float cosT)
{
  return F0 + fd90 * pow( 1 - cosT, 5);
}

//Frostbite
float Fr_DisneyDiffuse(float NdotV, float NdotL, float LdotH, float linearRoughness)
{
    float energyBias = mix(0, 0.5, linearRoughness);
    float energyFactor = mix(1.0, 1.0 / 1.51, linearRoughness);
    float fd90 = energyBias + 2.0 * LdotH*LdotH * linearRoughness;
    vec3 f0 = vec3(1.0f, 1.0f, 1.0f);
    float lightScatter = F_Schlick(f0, fd90, NdotL).r;
    float viewScatter = F_Schlick(f0, fd90, NdotV).r;
    return lightScatter * viewScatter * energyFactor;
}


//Based on Real Shading in Unreal Engine 4
//TODO: N & L, which coordinate space they are in?
vec3 SpecularIBLUE4(vec3 SpecularColor, float Roughness, vec3 N, vec3 V, out vec3 ks) {
    vec3 SpecularLighting = vec3(0.0);
    const int NumSamples = 256;//512;
    for(int i=0; i<NumSamples; i++) {
        vec2 Xi = Hammersley(i, NumSamples);
        //vec3 H = ImportanceSampleGGXUE4(Xi, Roughness, N);
        vec3 H = ImportanceSampleGGXUE4(Xi, Roughness, N);
        vec3 L = 2.0 * dot(V, H) * H - V;

        float NoV = saturate(dot(N, V));
        float NoL = saturate(dot(N, L));
        float NoH = saturate(dot(N, H));
        float VoH = saturate(dot(V, H));

        if (NoL > 0.0) {
            vec3 SampleColor = textureCube(uReflectionMap, envMapCube(L)).rgb;

            float G = G_Smith(Roughness, NoL, NoV);
            float Fc = pow(1.0 - VoH, 5.0);
            vec3 F = (1.0 - Fc) * SpecularColor + Fc;
            ks += F;
            SpecularLighting += SampleColor * F * G * VoH / (NoH * NoV);
        }
    }
    ks /= NumSamples;
    return SpecularLighting / NumSamples;
}

//Unreal Engine 4
void mainUE4() {
    FragData data;
    data.color = vec3(0.0);
    data.albedo = vec3(0.0);
    data.opacity = 1.0;
    data.positionWorld = vPositionWorld;
    data.positionView = vPositionView;
    data.normalWorld = normalize(vNormalWorld);
    data.normalView = normalize(vNormalView);
    data.texCoord = vTexCoord;
    data.eyePosView = vec3(0.0, 0.0, 0.0);
    data.eyeDirView = normalize(data.eyePosView - data.positionView);
    data.eyeDirWorld = vec3(uInverseViewMatrix * vec4(data.eyeDirView, 0.0));
    data.reflectionColor = vec3(0.0);
    data.exposure = uExposure;

    data.albedo = getAlbedo(data);
    data.roughness = getRoughness(data);
    data.metalness = getMetalness(data);
    data.irradianceColor = getIrradiance(data);

    //Specular F
    //Calculate colour at normal incidence
    vec3 F0 = vec3(0.04); //default for non-metals in UE4
    F0 = mix(F0, data.albedo, data.metalness);

    vec3 ks = vec3(0.0);
    vec3 n = data.normalWorld;
    vec3 v = data.eyeDirWorld;
    vec3 indirectSpecular = SpecularIBLUE4(F0, data.roughness, n, v, ks);
    vec3 kd = vec3((1.0 - ks) * (1.0 - data.metalness));
    data.color = kd * data.albedo * data.irradianceColor + ks * indirectSpecular;

    data.color *= uExposure;

    data.color = tonemapUncharted2(data.color);

    data.color = toGamma(data.color);

    gl_FragColor.rgb = data.color;
    gl_FragColor.a = data.opacity;

}

void main() {
    mainUE4();
}
