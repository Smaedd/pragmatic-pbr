#pragma glslify: envMapEquirect     = require(../../local_modules/glsl-envmap-equirect)
#pragma glslify: envMapCube         = require(../../local_modules/glsl-envmap-cube)
#pragma glslify: toGamma            = require(glsl-gamma/out)
#pragma glslify: toLinear           = require(glsl-gamma/in)
#pragma glslify: tonemapUncharted2  = require(../../local_modules/glsl-tonemap-uncharted2)
#pragma glslify: random             = require(glsl-random)

//Disney
//https://github.com/wdas/brdf/blob/master/src/brdfs/disney.brdf

#ifdef GL_ES
precision highp float;
#endif

#ifdef GL_ES
  #extension GL_EXT_shader_texture_lod : require
#else
  #extension GL_ARB_shader_texture_lod : require
#endif


uniform float uExposure;
uniform sampler2D uHammersleyPointSetMap;
uniform float uIor;

varying vec3 vNormalWorld;
varying vec3 vEyeDirWorld;

//Sampled from a texture generated by code based on
//http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
vec2 Hammersley(int i, int N) {
    return texture2D(uHammersleyPointSetMap, vec2(0.5, (float(i) + 0.5)/float(N))).rg;
}

float saturate(float f) {
    return clamp(f, 0.0, 1.0);
}

uniform vec4 uAlbedoColor; //assumes sRGB color, not linear

vec3 getAlbedo() {
    return toLinear(uAlbedoColor.rgb);
}

uniform float uRoughness;

float getRoughness() {
    return uRoughness;
}

uniform float uMetalness;

float getMetalness() {
    return uMetalness;
}

uniform samplerCube uReflectionMap;

uniform samplerCube uIrradianceMap;

vec3 getIrradiance(vec3 eyeDirWorld, vec3 normalWorld) {
    float maxMipMapLevel = 7.0; //TODO: const
    vec3 reflectionWorld = reflect(-eyeDirWorld, normalWorld);
    vec3 R = envMapCube(reflectionWorld);
    return textureCube(uIrradianceMap, R).rgb;
}

//Based on Real Shading in Unreal Engine 4
vec3 ImportanceSampleGGXUE4(vec2 Xi, float Roughness, vec3 N) {
    //this is mapping 2d point to a hemisphere but additionally we add spread by roughness
    float a = Roughness * Roughness;
    float Phi = 2.0 * PI * Xi.x + random(N.xz) * 0.1;
    float CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
    float SinTheta = sqrt(1.0 - CosTheta * CosTheta);
    vec3 H;
    H.x = SinTheta * cos(Phi);
    H.y = SinTheta * sin(Phi);
    H.z = CosTheta;

    //Tangent space vectors
    vec3 UpVector = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);
    vec3 TangentX = normalize(cross(UpVector, N));
    vec3 TangentY = normalize(cross(N, TangentX));

    //Tangent to World Space
    return TangentX * H.x + TangentY * H.y + N * H.z;

    //
    //vec3 n = N;
    //float aa = 1.0 / (1.0 + n.z);
    //float b = -n.x * n.y * aa;
    //vec3 b1 = vec3(1.0 - n.x * n.x * aa, b, -n.x);
    //vec3 b2 = vec3(b, 1.0 - n.y * n.y * aa, -n.y);
    //mat3 vecSpace = mat3(b1, b2, n);
    //return normalize(mix(vecSpace * H, N, 1.0 - Roughness));
}


float G_Smith(float Roughness, float NoL, float NoV) {
    float k = (Roughness + 1.0) * (Roughness + 1.0) / 8.0;
    float G1l = NoL / (NoL * (1.0 - k) + k);
    float G1v = NoV / (NoV * (1.0 - k) + k);
    float Glvh = G1l * G1v;
    return Glvh;
}

//Frostbite
vec3 F_Schlick(vec3 F0, float fd90, float cosT)
{
  return F0 + fd90 * pow( 1 - cosT, 5);
}

//Frostbite
float Fr_DisneyDiffuse(float NdotV, float NdotL, float LdotH, float linearRoughness)
{
    float energyBias = mix(0, 0.5, linearRoughness);
    float energyFactor = mix(1.0, 1.0 / 1.51, linearRoughness);
    float fd90 = energyBias + 2.0 * LdotH*LdotH * linearRoughness;
    vec3 f0 = vec3(1.0f, 1.0f, 1.0f);
    float lightScatter = F_Schlick(f0, fd90, NdotL).r;
    float viewScatter = F_Schlick(f0, fd90, NdotV).r;
    return lightScatter * viewScatter * energyFactor;
}


//Based on Real Shading in Unreal Engine 4
//TODO: N & L, which coordinate space they are in?
vec3 SpecularIBLUE4(vec3 SpecularColor, float Roughness, vec3 N, vec3 V, out vec3 ks) {
    vec3 SpecularLighting = vec3(0.0);
    const int NumSamples = 512;//512;
    for(int i=0; i<NumSamples; i++) {
        vec2 Xi = Hammersley(i, NumSamples);
        //vec3 H = ImportanceSampleGGXUE4(Xi, Roughness, N);
        vec3 H = ImportanceSampleGGXUE4(Xi, Roughness, N);
        vec3 L = 2.0 * dot(V, H) * H - V;

        float NoV = saturate(dot(N, V));
        float NoL = saturate(dot(N, L));
        float NoH = saturate(dot(N, H));
        float VoH = saturate(dot(V, H));

        if (NoL > 0.0) {
            vec3 SampleColor = textureCube(uReflectionMap, envMapCube(L)).rgb;

            float G = G_Smith(Roughness, NoL, NoV);
            float Fc = pow(1.0 - VoH, 5.0);
            vec3 F = (1.0 - Fc) * SpecularColor + Fc;
            ks += F;
            SpecularLighting += SampleColor * F * G * VoH / (NoH * NoV);
        }
    }
    ks /= NumSamples;
    return SpecularLighting / NumSamples;
}

varying vec3 vPositionView;
uniform mat4 uInverseViewMatrix;

void main() {
    vec3 normalWorld = normalize(vNormalWorld);
    vec3 eyeDirWorld = normalize(vEyeDirWorld);

    vec3 albedo = getAlbedo();
    float roughness = getRoughness();
    float metalness = getMetalness();
    vec3 irradianceColor = getIrradiance(eyeDirWorld, normalWorld);

    //Specular Color
    //Calculate colour at normal incidence
    vec3 F0 = vec3(abs((1.0 - uIor) / (1.0 + uIor)));
    F0 = F0 * F0;
    //F0 = toLinear(vec3(43.0/255.0));
    //F0 = vec3(0.04); //0.04 is default for non-metals in UE4
    F0 = mix(F0, albedo, metalness);

    vec3 ks = vec3(0.0);
    vec3 indirectSpecular = SpecularIBLUE4(F0, roughness, normalWorld, eyeDirWorld, ks);
    vec3 kd = vec3((1.0 - ks) * (1.0 - metalness));

    //Where this version with kd comes from?
    vec3 color = kd * albedo * irradianceColor + indirectSpecular;

    //vec3 color = albedo * irradianceColor + indirectSpecular;

    color *= uExposure;

    color = tonemapUncharted2(color);

    color = toGamma(color);

    gl_FragColor.rgb = color;
    gl_FragColor.a = 1.0;

}
